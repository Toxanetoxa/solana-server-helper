# Solana Fee Server

Сервис агрегации RPC для Solana, который подбирает приоритетные комиссии под разные уровни риска и рассылает рекомендации по WebSocket. Приложение измеряет задержки нескольких RPC-провайдеров, выбирает лучший согласно «липкой» эвристике, вычисляет рекомендуемую цену за вычислительные единицы (CU) и кеширует ответы в Redis, чтобы клиенты получали свежие данные каждые несколько секунд.

## Основные возможности

- Одновременная работа с несколькими RPC Solana (поддержка публичных и Ankr-эндпоинтов).
- Липкая стратегия выбора RPC с учётом выигрыша по задержке и минимального времени удержания.
- Вычисление рекомендуемой цены за CU и итоговой комиссии в лампортах/SOL для режимов риска `eco`, `balanced`, `aggr`.
- Веб-сокет шлюз с рассылкой рекомендаций и сменой режима клиента через команду `set_mode`.
- Краткосрочный кеш Redis, чтобы снижать нагрузку на RPC и обеспечивать быстрый ответ фронтенду.
- Готовые Docker-окружение и Makefile-таргеты для локального/production запуска.

## Архитектура и поток данных

1. **Конфигурация** (`src/config`) читает `.env`, нормализует URL RPC и выставляет пороги переключения.
2. **RPC-клиенты** (`src/infrastructure/rpc`) умеют:
    - мерить задержку (`getSlot`) и собирать снимок сети;
    - запрашивать последние prioritization fees (`getRecentPrioritizationFees`).
3. **RpcAggregator** выбирает лучший RPC: сравнивает латентности, применяет пороги `minDwellMs`, `minGainMs`, `minGainPct`, добавляет метки `notes` и возвращает снапшот + выбранного провайдера.
4. **Компонент вычисления** (`src/application/computeRecommendation.ts`) берёт снапшот, оценивает цену за CU (p75 по данным RPC или эвристика по задержке), строит итоговую рекомендацию через `domain/recommendation`.
5. **RedisCache** хранит рассчитанные рекомендации 6–6.5 секунд, чтобы WS-тик не бился о RPC чаще необходимого.
6. **WsGateway** отправляет клиентам JSON с подборкой под их риск-профиль. Клиент может сменить режим, послав `{"type":"set_mode","risk":"aggr"}`.
7. Главный цикл (`src/main.ts`) каждые `WS_BROADCAST_INTERVAL_MS` миллисекунд обновляет рекомендации и публикует их, пока процесс не остановят сигналами `SIGINT/SIGTERM`.

## Структура репозитория

```text
├─ src
│  ├─ application/        # use-case вычисления рекомендаций
│  ├─ config/             # загрузка и нормализация ENV
│  ├─ domain/             # доменная логика расчёта fee и метрик
│  ├─ infrastructure/
│  │  ├─ cache/           # Redis-клиент и кеш
│  │  ├─ rpc/             # адаптеры Solana RPC + агрегатор
│  │  └─ ws/              # WebSocket-шлюз
│  ├─ interface/          # DTO/валидации внешних сообщений
│  ├─ types/              # общие TypeScript-типы
│  └─ main.ts             # точка входа и цикл обновления
├─ docker/                # Dockerfile многостадийной сборки
├─ docker-compose*.yml    # окружения dev/prod
├─ Makefile               # удобные команды (up, down, logs и т.д.)
└─ dist/                  # результат tsc build (используется в проде)
```

## Требования

- Node.js ≥ 21 (используются ESM-модули и `fetch` из ядра).
- pnpm (corepack включается автоматически, но его можно установить глобально).
- Redis 7+ (локально можно поднять через docker-compose).

## Быстрый старт без Docker

1. Скопируйте пример конфигурации:

    ```bash
    cp .env.example .env
    ```

2. Укажите рабочие RPC в `.env` (`RPC_SOLANA`, `RPC_ANKR`) и, при необходимости, поменяйте `REDIS_URL`.
3. Установите зависимости и запустите dev-режим с авто-ребилдом:

    ```bash
    pnpm install
    pnpm run dev
    ```

4. Redis должен быть доступен по `REDIS_URL`. При отсутствии — поднимите отдельный инстанс (`redis-server` или `docker run redis:7-alpine`).

## Запуск через Docker Compose

```bash
make up          # собирает образы и поднимает app + redis
make logs        # стрим логов приложения
make down        # останавливает контейнеры
make clean       # полностью очищает (контейнеры + тома)
```

Dockerfile собирает TypeScript в `dist/`, финальный образ запускает `node dist/main.js`.

## Переменные окружения

| Переменная                 | Значение по умолчанию                 | Назначение                                                             |
| -------------------------- | ------------------------------------- | ---------------------------------------------------------------------- |
| `PORT`                     | `8787`                                | Порт WebSocket-сервера.                                                |
| `RPC_SOLANA`               | `https://api.mainnet-beta.solana.com` | Основной публичный RPC (опционально, но нужен хотя бы один endpoint).  |
| `RPC_ANKR`                 | `https://rpc.ankr.com/solana/`        | Альтернативный RPC (распознаётся как Ankr).                            |
| `WS_BROADCAST_INTERVAL_MS` | `10000`                               | Интервал между отправками рекомендаций.                                |
| `REDIS_URL`                | `redis://redis:6379`                  | Подключение к Redis (используется как кеш).                            |
| `REDIS_PREFIX`             | `fee:`                                | Префикс ключей в Redis.                                                |
| `RPC_MIN_DWELL_MS`         | `60000`                               | Минимальное время удержания текущего лучшего RPC.                      |
| `RPC_MIN_GAIN_MS`          | `10`                                  | Минимальный абсолютный выигрыш (мс), чтобы переключиться на новый RPC. |
| `RPC_MIN_GAIN_PCT`         | `0.1`                                 | Минимальный относительный выигрыш (10%).                               |
| `RPC_HEALTH_RETRIES`        | `2`                                  | Количество повторных health probe перед ошибкой.                       |
| `RPC_HEALTH_BACKOFF_INITIAL_MS` | `100`                            | Стартовая задержка между health повторами (мс).                        |
| `RPC_HEALTH_BACKOFF_MAX_MS` | `1500`                               | Максимальная задержка между health повторами (мс).                     |
| `RPC_FEES_RETRIES`         | `2`                                   | Повторных попыток получения prioritization fees.                       |
| `RPC_FEES_BACKOFF_INITIAL_MS` | `100`                              | Стартовая задержка между повторами fees-запроса (мс).                  |
| `RPC_FEES_BACKOFF_MAX_MS`  | `1500`                                | Максимальная задержка между повторами fees-запроса (мс).               |
| `RPC_CIRCUIT_FAILURE_THRESHOLD`  | `3`                             | Сколько подряд сбоев нужно, чтобы открыть circuit breaker.             |
| `RPC_CIRCUIT_COOLDOWN_MS`  | `30000`                               | Сколько ждать до повторной попытки проблемного RPC (мс).               |
Все значения читаются из `.env`, лишние кавычки/пробелы автоматически удаляются (`src/config/config.ts`).

## WebSocket API

- **Endpoint**: `ws://<host>:<PORT>` (по умолчанию `ws://localhost:8787`).
- **Подписка**: сразу после подключения сервер начнёт слать JSON для режима `balanced`.
- **Смена режима**: отправьте команду

    ```json
    { "type": "set_mode", "risk": "aggr" }
    ```

    Допустимые значения `risk`: `"eco"`, `"balanced"`, `"aggr"`.

- **Формат ответа**:

    ```json
    {
     "mode": "balanced",
     "cuPrice": 4200,
     "cuEstimate": 32500,
     "priorityFeeLamports": 136,
     "successScore": 0.92,
     "recommendedRpc": "https://rpc.ankr.com/solana/abcd",
     "updatedAt": "2024-06-12T08:12:31.123Z",
     "notes": ["rpc switched -> ..."]
    }
    ```

    Поле `notes` объединяет комментарии RPC-агрегатора и вычислителя (например, о переключении или о stale-состоянии).

## Кеш и устойчивость

- Рекомендации кешируются в Redis на ~6 секунд с небольшим джиттером, чтобы сократить одновременную нагрузку на RPC.
- Если все RPC-запросы упали, сервер пошлёт `stale` снапшот и не будет переключать клиентов до восстановления.
- Graceful shutdown закрывает WS-подписчиков и аккуратно гасит Redis-клиент.

## Скрипты и инструменты

- `pnpm run dev` — запуск с `tsx watch` (hot reload).
- `pnpm run build` — компиляция TypeScript в `dist/`.
- `pnpm run start` — запуск собранного бандла (`node dist/main.js`).
- `pnpm run lint` / `lint:fix` — проверка кода ESLint + Prettier.

## Пре-коммит проверки

- После `pnpm install` автоматически активируется Husky, поэтому локальные гит-хуки устанавливаются без ручных шагов.
- Перед каждым коммитом запускается `pnpm exec lint-staged` (форматирует Prettier и прогоняет ESLint по staged-файлам, кроме Markdown) и `pnpm test`; при любой ошибке commit отменяется.
- Для ручной починки форматирования используйте `pnpm format:fix`, а для глобального линта — `pnpm lint` или `pnpm lint:fix`.

## Деплой

- Для production используйте `docker-compose.prod.yml`: задайте переменную `IMAGE` с готовым образом (например, собранным CI).
- Образ `fee-app` содержит только `dist/` и production-зависимости, поэтому перед развертыванием выполните `pnpm run build`.
- Redis подключается по `REDIS_URL`; при развёртывании в разных сетях убедитесь, что приложение видит Redis-сервис.

## Траблшутинг

- **Нет RPC-эндпоинтов**: приложение завершится с ошибкой «No RPC endpoints configured». Проверьте `RPC_SOLANA`/`RPC_ANKR` в `.env` и отсутствие лишних пробелов.
- **Redis недоступен**: в логах появится `[redis] error`. Убедитесь, что контейнер Redis запущен и что `REDIS_URL` указывает на него.
- **WS-подключения не закрываются**: по умолчанию сервер форсит закрытие за `timeout` (2 секунды). Настройкой можно управлять из кода (`WsGateway.close`).

---

Если нужна дополнительная автоматизация или интеграция с фронтендом — посмотрите, как формируются данные в `src/interface/fee.dto.ts` и `WsGateway`, чтобы синхронно обновить схемы и клиентские типы.
